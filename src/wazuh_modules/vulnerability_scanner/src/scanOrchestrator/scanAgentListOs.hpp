/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 13, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_AGENT_LIST_OS_HPP
#define _SCAN_AGENT_LIST_OS_HPP

#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief Orchestrates queries to the global Wazuh-DB system and initiates package scanning.
 *
 * The `TScanAgentListOs` class is responsible for coordinating the execution of queries within the
 * broader Wazuh ecosystem.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext,
         typename TAbstractHandler = AbstractHandler<std::shared_ptr<TScanContext>>>
class TScanAgentListOs final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TAbstractHandler> m_suborchestration;

public:
    /**
     * @brief Construct a new global fetch object
     *
     * @param packageInsertOrchestration package orchestration instance.
     */
    explicit TScanAgentListOs(std::shared_ptr<TAbstractHandler> packageInsertOrchestration)
        : m_suborchestration(std::move(packageInsertOrchestration))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data A shared pointer to the input data.
     * @return A shared pointer to the result of the request processing.
     *
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        // Instance the socketWrapper for Wazuh-DB
        static SocketDBWrapper wdbSocketWrapper(WDB_SOCKET);

        nlohmann::json response;
        for (const auto& agent : data->m_agents)
        {
            // This could throw a exception if there is not information about the os, because the user
            // disable it from syscollector or the database is syncronizing.
            try
            {
                wdbSocketWrapper.query(WazuhDBQueryBuilder::builder().agentGetOsInfoCommand(agent.id).build(),
                                       response);

                // Validate the response
                if (response.empty())
                {
                    logWarn(
                        WM_VULNSCAN_LOGTAG, "Empty response for agent '%s' in Wazuh-DB 'sys_' query", agent.id.c_str());
                    continue;
                }

                for (const auto& osInfo : response)
                {
                    flatbuffers::FlatBufferBuilder fbBuilder;
                    auto agentInfo = SyscollectorSynchronization::CreateAgentInfoDirect(fbBuilder,
                                                                                        agent.id.c_str(),
                                                                                        agent.ip.c_str(),
                                                                                        agent.name.c_str(),
                                                                                        agent.version.c_str(),
                                                                                        agent.node.c_str());
                    auto syscollectorOs = SyscollectorSynchronization::Createsyscollector_osinfoDirect(
                        fbBuilder,
                        osInfo.value("checksum", "").c_str(),
                        osInfo.value("hostname", "").c_str(),
                        osInfo.value("os_build", "").c_str(),
                        osInfo.value("os_codename", "").c_str(),
                        osInfo.value("os_display_version", "").c_str(),
                        osInfo.value("os_major", "").c_str(),
                        osInfo.value("os_minor", "").c_str(),
                        osInfo.value("os_name", "").c_str(),
                        osInfo.value("os_patch", "").c_str(),
                        osInfo.value("os_platform", "").c_str(),
                        osInfo.value("os_release", "").c_str(),
                        osInfo.value("os_version", "").c_str(),
                        osInfo.value("release", "").c_str(),
                        osInfo.value("scan_time", "").c_str(),
                        osInfo.value("sysname", "").c_str(),
                        osInfo.value("version", "").c_str());

                    auto stateMsg = SyscollectorSynchronization::Createstate(
                        fbBuilder,
                        SyscollectorSynchronization::AttributesUnion::AttributesUnion_syscollector_osinfo,
                        syscollectorOs.Union());

                    auto syncMsg = SyscollectorSynchronization::CreateSyncMsg(
                        fbBuilder,
                        agentInfo,
                        SyscollectorSynchronization::DataUnion::DataUnion_state,
                        stateMsg.Union());

                    fbBuilder.Finish(syncMsg);

                    std::variant<const SyscollectorDeltas::Delta*,
                                 const SyscollectorSynchronization::SyncMsg*,
                                 const nlohmann::json*>
                        variantData = SyscollectorSynchronization::GetSyncMsg(fbBuilder.GetBufferPointer());

                    auto context = std::make_shared<TScanContext>(variantData);

                    m_suborchestration->handleRequest(std::move(context));
                }
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG, "Error handling request: %s", e.what());
            }
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using ScanAgentListOs = TScanAgentListOs<>;

#endif // _SCAN_AGENT_LIST_OS_HPP
